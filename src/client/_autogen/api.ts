/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * DCS Dropzone Registry API
 * API documentation for the DCS Dropzone Registry.
 * OpenAPI spec version: 1.0.0
 */
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  useQuery
} from 'react-query';
import type {
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryResult
} from 'react-query';

/**
 * The currently authenticated user
 */
export interface AuthenticatedUser {
  /** The user's unique ID as a string, which is provided by the OAuth provider */
  id: string;
  /** The user's name, if available. This is not always provided by the OAuth provider */
  name?: string;
  /** The user's login, which is unique to the OAuth provider */
  login: string;
  /** The user's avatar URL, which can be used to display the user's profile picture */
  avatarUrl: string;
  /** The user's profile URL, which can be used to view the user's profile on the OAuth provider's website */
  profileUrl: string;
  /** Whether the user is a sudo user */
  sudo: boolean;
}

export type GetAuthProviderCallbackParams = {
code: string;
state: string;
};

export type GetApiHealth200 = {
  status: 'UP';
};

export type GetApiHealth503 = {
  status: 'DOWN';
  error: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Handles the OAuth provider's callback after the user has authenticated. The callback URL includes the user's access token and other information.
 * @summary OAuth provider callback
 */
export const getAuthProviderCallback = (
    provider: 'github',
    params: GetAuthProviderCallbackParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/auth/${provider}/callback`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAuthProviderCallbackQueryKey = (provider?: 'github',
    params?: GetAuthProviderCallbackParams,) => {
    return [
    `/auth/${provider}/callback`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAuthProviderCallbackQueryOptions = <TData = Awaited<ReturnType<typeof getAuthProviderCallback>>, TError = AxiosError<unknown>>(provider: 'github',
    params: GetAuthProviderCallbackParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderCallback>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthProviderCallbackQueryKey(provider,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthProviderCallback>>> = ({ signal }) => getAuthProviderCallback(provider,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(provider), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderCallback>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthProviderCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthProviderCallback>>>
export type GetAuthProviderCallbackQueryError = AxiosError<unknown>


/**
 * @summary OAuth provider callback
 */

export function useGetAuthProviderCallback<TData = Awaited<ReturnType<typeof getAuthProviderCallback>>, TError = AxiosError<unknown>>(
 provider: 'github',
    params: GetAuthProviderCallbackParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderCallback>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAuthProviderCallbackQueryOptions(provider,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Redirects the user to the OAuth provider's authorization page (e.g., GitHub) to initiate the authentication process.
 * @summary Redirect to OAuth provider login page
 */
export const getAuthProviderLogin = (
    provider: 'github', options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/auth/${provider}/login`,options
    );
  }




export const getGetAuthProviderLoginQueryKey = (provider?: 'github',) => {
    return [
    `/auth/${provider}/login`
    ] as const;
    }

    
export const getGetAuthProviderLoginQueryOptions = <TData = Awaited<ReturnType<typeof getAuthProviderLogin>>, TError = AxiosError<unknown>>(provider: 'github', options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderLogin>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthProviderLoginQueryKey(provider);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthProviderLogin>>> = ({ signal }) => getAuthProviderLogin(provider, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(provider), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderLogin>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthProviderLoginQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthProviderLogin>>>
export type GetAuthProviderLoginQueryError = AxiosError<unknown>


/**
 * @summary Redirect to OAuth provider login page
 */

export function useGetAuthProviderLogin<TData = Awaited<ReturnType<typeof getAuthProviderLogin>>, TError = AxiosError<unknown>>(
 provider: 'github', options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderLogin>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAuthProviderLoginQueryOptions(provider,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the details of the authenticated user, including their ID, login, avatar URL, and profile URL.
 Requires a valid authentication session (cookie-based authentication).
 * @summary Get authenticated user data
 */
export const getAuthUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthenticatedUser>> => {
    
    
    return axios.default.get(
      `/auth/user`,options
    );
  }




export const getGetAuthUserQueryKey = () => {
    return [
    `/auth/user`
    ] as const;
    }

    
export const getGetAuthUserQueryOptions = <TData = Awaited<ReturnType<typeof getAuthUser>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthUser>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthUser>>> = ({ signal }) => getAuthUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthUserQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthUser>>>
export type GetAuthUserQueryError = AxiosError<unknown>


/**
 * @summary Get authenticated user data
 */

export function useGetAuthUser<TData = Awaited<ReturnType<typeof getAuthUser>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthUser>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAuthUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Logs the user out by clearing the session cookie.
 * @summary Logout
 */
export const getAuthLogout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/auth/logout`,options
    );
  }




export const getGetAuthLogoutQueryKey = () => {
    return [
    `/auth/logout`
    ] as const;
    }

    
export const getGetAuthLogoutQueryOptions = <TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthLogoutQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthLogout>>> = ({ signal }) => getAuthLogout({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthLogoutQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthLogout>>>
export type GetAuthLogoutQueryError = AxiosError<unknown>


/**
 * @summary Logout
 */

export function useGetAuthLogout<TData = Awaited<ReturnType<typeof getAuthLogout>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthLogout>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAuthLogoutQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Say hello to the user
 */
export const getApiHealth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetApiHealth200>> => {
    
    
    return axios.default.get(
      `/api/health`,options
    );
  }




export const getGetApiHealthQueryKey = () => {
    return [
    `/api/health`
    ] as const;
    }

    
export const getGetApiHealthQueryOptions = <TData = Awaited<ReturnType<typeof getApiHealth>>, TError = AxiosError<GetApiHealth503>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiHealth>>> = ({ signal }) => getApiHealth({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData> & { queryKey: QueryKey }
}

export type GetApiHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getApiHealth>>>
export type GetApiHealthQueryError = AxiosError<GetApiHealth503>



export function useGetApiHealth<TData = Awaited<ReturnType<typeof getApiHealth>>, TError = AxiosError<GetApiHealth503>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getApiHealth>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetApiHealthQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
