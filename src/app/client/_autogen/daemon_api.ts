/**
 * Generated by orval v8.0.0-rc.0 üç∫
 * Do not edit manually.
 * DCS Dropzone Daemon API
 * API documentation for the DCS Dropzone Daemon.
 * OpenAPI spec version: 1.0.0
 */

import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";
import { useMutation, useQuery } from "@tanstack/react-query";

import { daemonFetch } from "./daemon_fetch_client";
export type ModReleaseAssetStatusDataStatus =
	(typeof ModReleaseAssetStatusDataStatus)[keyof typeof ModReleaseAssetStatusDataStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModReleaseAssetStatusDataStatus = {
	PENDING: "PENDING",
	IN_PROGRESS: "IN_PROGRESS",
	COMPLETED: "COMPLETED",
	ERROR: "ERROR",
} as const;

/**
 * Status data representation of a mod release asset, including download and extraction progress.
 */
export interface ModReleaseAssetStatusData {
	downloadPercentProgress?: number;
	extractPercentProgress?: number;
	overallPercentProgress?: number;
	status: ModReleaseAssetStatusDataStatus;
}

/**
 * Data representation of a mod release asset.
 */
export interface ModReleaseAssetData {
	/** @minLength 1 */
	name: string;
	urls: string[];
	isArchive: boolean;
	statusData?: ModReleaseAssetStatusData;
}

export type ModReleaseSymbolicLinkDataDestRoot =
	(typeof ModReleaseSymbolicLinkDataDestRoot)[keyof typeof ModReleaseSymbolicLinkDataDestRoot];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModReleaseSymbolicLinkDataDestRoot = {
	DCS_WORKING_DIR: "DCS_WORKING_DIR",
	DCS_INSTALL_DIR: "DCS_INSTALL_DIR",
} as const;

/**
 * Data representation of a symbolic link configuration.
 */
export interface ModReleaseSymbolicLinkData {
	/** @minLength 1 */
	name: string;
	/** @minLength 1 */
	src: string;
	/** @minLength 1 */
	dest: string;
	destRoot: ModReleaseSymbolicLinkDataDestRoot;
}

export type ModReleaseMissionScriptDataRoot =
	(typeof ModReleaseMissionScriptDataRoot)[keyof typeof ModReleaseMissionScriptDataRoot];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModReleaseMissionScriptDataRoot = {
	DCS_WORKING_DIR: "DCS_WORKING_DIR",
	DCS_INSTALL_DIR: "DCS_INSTALL_DIR",
} as const;

export type ModReleaseMissionScriptDataRunOn =
	(typeof ModReleaseMissionScriptDataRunOn)[keyof typeof ModReleaseMissionScriptDataRunOn];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModReleaseMissionScriptDataRunOn = {
	MISSION_START_BEFORE_SANITIZE: "MISSION_START_BEFORE_SANITIZE",
	MISSION_START_AFTER_SANITIZE: "MISSION_START_AFTER_SANITIZE",
} as const;

/**
 * Data representation of a mission script configuration.
 */
export interface ModReleaseMissionScriptData {
	/** @minLength 1 */
	name: string;
	/** @minLength 1 */
	purpose: string;
	/** @minLength 1 */
	path: string;
	root: ModReleaseMissionScriptDataRoot;
	runOn: ModReleaseMissionScriptDataRunOn;
}

export type ModAndReleaseDataStatus = (typeof ModAndReleaseDataStatus)[keyof typeof ModAndReleaseDataStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModAndReleaseDataStatus = {
	PENDING: "PENDING",
	IN_PROGRESS: "IN_PROGRESS",
	DISABLED: "DISABLED",
	ENABLED: "ENABLED",
	ERROR: "ERROR",
} as const;

/**
 * Data representation of a mod along with its release for downloading and enabling.
 */
export interface ModAndReleaseData {
	releaseId: string;
	modId: string;
	modName: string;
	dependencies: string[];
	version: string;
	assets: ModReleaseAssetData[];
	symbolicLinks: ModReleaseSymbolicLinkData[];
	missionScripts: ModReleaseMissionScriptData[];
	status?: ModAndReleaseDataStatus;
	overallPercentProgress?: number;
}

export type GetDaemonHealth200 = {
	status: "UP";
	daemonInstanceId: string;
};

export type GetDaemonHealth503 = {
	status: "DOWN";
	daemonInstanceId: string;
	error: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Checks the daemon service health by performing a lightweight database operation.
 * @summary Daemon health check
 */
export type getDaemonHealthResponse200 = {
	data: GetDaemonHealth200;
	status: 200;
};

export type getDaemonHealthResponse503 = {
	data: GetDaemonHealth503;
	status: 503;
};

export type getDaemonHealthResponseSuccess = getDaemonHealthResponse200 & {
	headers: Headers;
};
export type getDaemonHealthResponseError = getDaemonHealthResponse503 & {
	headers: Headers;
};

export type getDaemonHealthResponse = getDaemonHealthResponseSuccess | getDaemonHealthResponseError;

export const getGetDaemonHealthUrl = () => {
	return `/api/health`;
};

export const getDaemonHealth = async (options?: RequestInit): Promise<getDaemonHealthResponse> => {
	return daemonFetch<getDaemonHealthResponse>(getGetDaemonHealthUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetDaemonHealthQueryKey = () => {
	return [`/api/health`] as const;
};

export const getGetDaemonHealthQueryOptions = <
	TData = Awaited<ReturnType<typeof getDaemonHealth>>,
	TError = GetDaemonHealth503,
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>>;
	request?: SecondParameter<typeof daemonFetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetDaemonHealthQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaemonHealth>>> = ({ signal }) =>
		getDaemonHealth({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getDaemonHealth>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDaemonHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getDaemonHealth>>>;
export type GetDaemonHealthQueryError = GetDaemonHealth503;

export function useGetDaemonHealth<TData = Awaited<ReturnType<typeof getDaemonHealth>>, TError = GetDaemonHealth503>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getDaemonHealth>>,
					TError,
					Awaited<ReturnType<typeof getDaemonHealth>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaemonHealth<TData = Awaited<ReturnType<typeof getDaemonHealth>>, TError = GetDaemonHealth503>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getDaemonHealth>>,
					TError,
					Awaited<ReturnType<typeof getDaemonHealth>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDaemonHealth<TData = Awaited<ReturnType<typeof getDaemonHealth>>, TError = GetDaemonHealth503>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Daemon health check
 */

export function useGetDaemonHealth<TData = Awaited<ReturnType<typeof getDaemonHealth>>, TError = GetDaemonHealth503>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getGetDaemonHealthQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export type addReleaseToDaemonResponse200 = {
	data: void;
	status: 200;
};

export type addReleaseToDaemonResponseSuccess = addReleaseToDaemonResponse200 & {
	headers: Headers;
};

export type addReleaseToDaemonResponse = addReleaseToDaemonResponseSuccess;

export const getAddReleaseToDaemonUrl = () => {
	return `/api/downloads`;
};

export const addReleaseToDaemon = async (
	modAndReleaseData: ModAndReleaseData,
	options?: RequestInit,
): Promise<addReleaseToDaemonResponse> => {
	return daemonFetch<addReleaseToDaemonResponse>(getAddReleaseToDaemonUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(modAndReleaseData),
	});
};

export const getAddReleaseToDaemonMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof addReleaseToDaemon>>,
		TError,
		{ data: ModAndReleaseData },
		TContext
	>;
	request?: SecondParameter<typeof daemonFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof addReleaseToDaemon>>,
	TError,
	{ data: ModAndReleaseData },
	TContext
> => {
	const mutationKey = ["addReleaseToDaemon"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof addReleaseToDaemon>>, { data: ModAndReleaseData }> = (
		props,
	) => {
		const { data } = props ?? {};

		return addReleaseToDaemon(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AddReleaseToDaemonMutationResult = NonNullable<Awaited<ReturnType<typeof addReleaseToDaemon>>>;
export type AddReleaseToDaemonMutationBody = ModAndReleaseData;
export type AddReleaseToDaemonMutationError = unknown;

export const useAddReleaseToDaemon = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof addReleaseToDaemon>>,
			TError,
			{ data: ModAndReleaseData },
			TContext
		>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof addReleaseToDaemon>>, TError, { data: ModAndReleaseData }, TContext> => {
	const mutationOptions = getAddReleaseToDaemonMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

export type getAllDaemonReleasesResponse200 = {
	data: ModAndReleaseData[];
	status: 200;
};

export type getAllDaemonReleasesResponseSuccess = getAllDaemonReleasesResponse200 & {
	headers: Headers;
};

export type getAllDaemonReleasesResponse = getAllDaemonReleasesResponseSuccess;

export const getGetAllDaemonReleasesUrl = () => {
	return `/api/downloads`;
};

export const getAllDaemonReleases = async (options?: RequestInit): Promise<getAllDaemonReleasesResponse> => {
	return daemonFetch<getAllDaemonReleasesResponse>(getGetAllDaemonReleasesUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetAllDaemonReleasesQueryKey = () => {
	return [`/api/downloads`] as const;
};

export const getGetAllDaemonReleasesQueryOptions = <
	TData = Awaited<ReturnType<typeof getAllDaemonReleases>>,
	TError = unknown,
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>>;
	request?: SecondParameter<typeof daemonFetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAllDaemonReleasesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllDaemonReleases>>> = ({ signal }) =>
		getAllDaemonReleases({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAllDaemonReleases>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllDaemonReleasesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllDaemonReleases>>>;
export type GetAllDaemonReleasesQueryError = unknown;

export function useGetAllDaemonReleases<TData = Awaited<ReturnType<typeof getAllDaemonReleases>>, TError = unknown>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAllDaemonReleases>>,
					TError,
					Awaited<ReturnType<typeof getAllDaemonReleases>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllDaemonReleases<TData = Awaited<ReturnType<typeof getAllDaemonReleases>>, TError = unknown>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAllDaemonReleases>>,
					TError,
					Awaited<ReturnType<typeof getAllDaemonReleases>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllDaemonReleases<TData = Awaited<ReturnType<typeof getAllDaemonReleases>>, TError = unknown>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetAllDaemonReleases<TData = Awaited<ReturnType<typeof getAllDaemonReleases>>, TError = unknown>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getGetAllDaemonReleasesQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export type removeReleaseFromDaemonResponse200 = {
	data: void;
	status: 200;
};

export type removeReleaseFromDaemonResponseSuccess = removeReleaseFromDaemonResponse200 & {
	headers: Headers;
};

export type removeReleaseFromDaemonResponse = removeReleaseFromDaemonResponseSuccess;

export const getRemoveReleaseFromDaemonUrl = (releaseId: string) => {
	return `/api/downloads/${releaseId}`;
};

export const removeReleaseFromDaemon = async (
	releaseId: string,
	options?: RequestInit,
): Promise<removeReleaseFromDaemonResponse> => {
	return daemonFetch<removeReleaseFromDaemonResponse>(getRemoveReleaseFromDaemonUrl(releaseId), {
		...options,
		method: "DELETE",
	});
};

export const getRemoveReleaseFromDaemonMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof removeReleaseFromDaemon>>,
		TError,
		{ releaseId: string },
		TContext
	>;
	request?: SecondParameter<typeof daemonFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof removeReleaseFromDaemon>>,
	TError,
	{ releaseId: string },
	TContext
> => {
	const mutationKey = ["removeReleaseFromDaemon"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeReleaseFromDaemon>>, { releaseId: string }> = (
		props,
	) => {
		const { releaseId } = props ?? {};

		return removeReleaseFromDaemon(releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RemoveReleaseFromDaemonMutationResult = NonNullable<Awaited<ReturnType<typeof removeReleaseFromDaemon>>>;

export type RemoveReleaseFromDaemonMutationError = unknown;

export const useRemoveReleaseFromDaemon = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof removeReleaseFromDaemon>>,
			TError,
			{ releaseId: string },
			TContext
		>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof removeReleaseFromDaemon>>, TError, { releaseId: string }, TContext> => {
	const mutationOptions = getRemoveReleaseFromDaemonMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Enable a release by creating its symbolic links
 */
export type enableReleaseResponse200 = {
	data: void;
	status: 200;
};

export type enableReleaseResponseSuccess = enableReleaseResponse200 & {
	headers: Headers;
};

export type enableReleaseResponse = enableReleaseResponseSuccess;

export const getEnableReleaseUrl = (releaseId: string) => {
	return `/api/toggle/${releaseId}/enable`;
};

export const enableRelease = async (releaseId: string, options?: RequestInit): Promise<enableReleaseResponse> => {
	return daemonFetch<enableReleaseResponse>(getEnableReleaseUrl(releaseId), {
		...options,
		method: "POST",
	});
};

export const getEnableReleaseMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext>;
	request?: SecondParameter<typeof daemonFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext> => {
	const mutationKey = ["enableRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableRelease>>, { releaseId: string }> = (props) => {
		const { releaseId } = props ?? {};

		return enableRelease(releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type EnableReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof enableRelease>>>;

export type EnableReleaseMutationError = unknown;

/**
 * @summary Enable a release by creating its symbolic links
 */
export const useEnableRelease = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext> => {
	const mutationOptions = getEnableReleaseMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Disable a release by removing its symbolic links
 */
export type disableReleaseResponse200 = {
	data: void;
	status: 200;
};

export type disableReleaseResponseSuccess = disableReleaseResponse200 & {
	headers: Headers;
};

export type disableReleaseResponse = disableReleaseResponseSuccess;

export const getDisableReleaseUrl = (releaseId: string) => {
	return `/api/toggle/${releaseId}/disable`;
};

export const disableRelease = async (releaseId: string, options?: RequestInit): Promise<disableReleaseResponse> => {
	return daemonFetch<disableReleaseResponse>(getDisableReleaseUrl(releaseId), {
		...options,
		method: "POST",
	});
};

export const getDisableReleaseMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext>;
	request?: SecondParameter<typeof daemonFetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext> => {
	const mutationKey = ["disableRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableRelease>>, { releaseId: string }> = (props) => {
		const { releaseId } = props ?? {};

		return disableRelease(releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DisableReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof disableRelease>>>;

export type DisableReleaseMutationError = unknown;

/**
 * @summary Disable a release by removing its symbolic links
 */
export const useDisableRelease = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext>;
		request?: SecondParameter<typeof daemonFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext> => {
	const mutationOptions = getDisableReleaseMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
