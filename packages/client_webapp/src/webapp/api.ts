/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * DCS Dropzone Registry API
 * API documentation for the DCS Dropzone Registry.
 * OpenAPI spec version: 1.0.0
 */

import type {
	MutationFunction,
	QueryFunction,
	QueryKey,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";
import { useMutation, useQuery } from "@tanstack/react-query";

import { fetch } from "./client";
/**
 * Data representation of a user.
 */
export interface UserData {
	id: string;
	username: string;
	name?: string;
	avatarUrl: string;
	profileUrl: string;
}

export interface ErrorData {
	/**
	 * @minimum 100
	 * @maximum 599
	 */
	code: number;
	message?: string;
	error: string;
}

export type ModSummaryDataCategory = (typeof ModSummaryDataCategory)[keyof typeof ModSummaryDataCategory];

export const ModSummaryDataCategory = {
	CAMPAIGN: "CAMPAIGN",
	DEVICE_PROFILES: "DEVICE_PROFILES",
	MOD: "MOD",
	MISSION: "MISSION",
	SKIN: "SKIN",
	SOUND: "SOUND",
	TERRAIN: "TERRAIN",
	UTILITY: "UTILITY",
	OTHER: "OTHER",
} as const;

/**
 * Summary Data representation of a mod.
 */
export interface ModSummaryData {
	id: string;
	name: string;
	category: ModSummaryDataCategory;
	description: string;
	thumbnail: string;
	dependencies: string[];
	/** @minItems 1 */
	maintainers: string[];
	tags: string[];
	downloadsCount: number;
}

export type ModAvailableFilterDataCategoriesItem =
	(typeof ModAvailableFilterDataCategoriesItem)[keyof typeof ModAvailableFilterDataCategoriesItem];

export const ModAvailableFilterDataCategoriesItem = {
	CAMPAIGN: "CAMPAIGN",
	DEVICE_PROFILES: "DEVICE_PROFILES",
	MOD: "MOD",
	MISSION: "MISSION",
	SKIN: "SKIN",
	SOUND: "SOUND",
	TERRAIN: "TERRAIN",
	UTILITY: "UTILITY",
	OTHER: "OTHER",
} as const;

export type ModAvailableFilterDataMaintainersItem = {
	id: string;
	username: string;
};

/**
 * Data structure for filtering mods.
 */
export interface ModAvailableFilterData {
	categories: ModAvailableFilterDataCategoriesItem[];
	maintainers: ModAvailableFilterDataMaintainersItem[];
	tags: string[];
}

export type ModDataCategory = (typeof ModDataCategory)[keyof typeof ModDataCategory];

export const ModDataCategory = {
	CAMPAIGN: "CAMPAIGN",
	DEVICE_PROFILES: "DEVICE_PROFILES",
	MOD: "MOD",
	MISSION: "MISSION",
	SKIN: "SKIN",
	SOUND: "SOUND",
	TERRAIN: "TERRAIN",
	UTILITY: "UTILITY",
	OTHER: "OTHER",
} as const;

export type ModDataVisibility = (typeof ModDataVisibility)[keyof typeof ModDataVisibility];

export const ModDataVisibility = {
	PUBLIC: "PUBLIC",
	PRIVATE: "PRIVATE",
	UNLISTED: "UNLISTED",
} as const;

/**
 * Data representation of a mod.
 */
export interface ModData {
	category: ModDataCategory;
	content: string;
	dependencies: string[];
	description: string;
	downloadsCount: number;
	id: string;
	latestReleaseId?: string | null;
	/** @minItems 1 */
	maintainers: string[];
	name: string;
	screenshots: string[];
	tags: string[];
	thumbnail: string;
	visibility: ModDataVisibility;
}

export type ModReleaseAssetDataUrlsItem = {
	id: string;
	url: string;
};

/**
 * Data representation of a mod release asset.
 */
export interface ModReleaseAssetData {
	id: string;
	/** @minLength 1 */
	name: string;
	urls: ModReleaseAssetDataUrlsItem[];
	isArchive: boolean;
}

export type ModReleaseSymbolicLinkDataDestRoot =
	(typeof ModReleaseSymbolicLinkDataDestRoot)[keyof typeof ModReleaseSymbolicLinkDataDestRoot];

export const ModReleaseSymbolicLinkDataDestRoot = {
	DCS_WORKING_DIR: "DCS_WORKING_DIR",
	DCS_INSTALL_DIR: "DCS_INSTALL_DIR",
} as const;

/**
 * Data representation of a symbolic link configuration.
 */
export interface ModReleaseSymbolicLinkData {
	id: string;
	/** @minLength 1 */
	name: string;
	/** @minLength 1 */
	src: string;
	/** @minLength 1 */
	dest: string;
	destRoot: ModReleaseSymbolicLinkDataDestRoot;
}

export type ModReleaseMissionScriptDataRoot =
	(typeof ModReleaseMissionScriptDataRoot)[keyof typeof ModReleaseMissionScriptDataRoot];

export const ModReleaseMissionScriptDataRoot = {
	DCS_WORKING_DIR: "DCS_WORKING_DIR",
	DCS_INSTALL_DIR: "DCS_INSTALL_DIR",
} as const;

export type ModReleaseMissionScriptDataRunOn =
	(typeof ModReleaseMissionScriptDataRunOn)[keyof typeof ModReleaseMissionScriptDataRunOn];

export const ModReleaseMissionScriptDataRunOn = {
	MISSION_START_BEFORE_SANITIZE: "MISSION_START_BEFORE_SANITIZE",
	MISSION_START_AFTER_SANITIZE: "MISSION_START_AFTER_SANITIZE",
} as const;

/**
 * Data representation of a mission script configuration.
 */
export interface ModReleaseMissionScriptData {
	id: string;
	/** @minLength 1 */
	name: string;
	/** @minLength 1 */
	purpose: string;
	/** @minLength 1 */
	path: string;
	root: ModReleaseMissionScriptDataRoot;
	runOn: ModReleaseMissionScriptDataRunOn;
}

export type ModReleaseDataVisibility = (typeof ModReleaseDataVisibility)[keyof typeof ModReleaseDataVisibility];

export const ModReleaseDataVisibility = {
	PUBLIC: "PUBLIC",
	PRIVATE: "PRIVATE",
	UNLISTED: "UNLISTED",
} as const;

/**
 * Data representation of a mod release.
 */
export interface ModReleaseData {
	id: string;
	modId: string;
	version: string;
	versionHash: string;
	changelog: string;
	assets: ModReleaseAssetData[];
	symbolicLinks: ModReleaseSymbolicLinkData[];
	missionScripts: ModReleaseMissionScriptData[];
	visibility: ModReleaseDataVisibility;
	downloadsCount?: number;
	createdAt?: string;
	updatedAt?: string;
}

export interface OkData {
	ok?: boolean;
}

/**
 * Metadata representation of a user's mods.
 */
export interface UserModsMetaData {
	published: number;
	totalDownloads: number;
}

export type ModCreateDataCategory = (typeof ModCreateDataCategory)[keyof typeof ModCreateDataCategory];

export const ModCreateDataCategory = {
	CAMPAIGN: "CAMPAIGN",
	DEVICE_PROFILES: "DEVICE_PROFILES",
	MOD: "MOD",
	MISSION: "MISSION",
	SKIN: "SKIN",
	SOUND: "SOUND",
	TERRAIN: "TERRAIN",
	UTILITY: "UTILITY",
	OTHER: "OTHER",
} as const;

/**
 * Data required to create a new mod.
 */
export interface ModCreateData {
	name: string;
	category: ModCreateDataCategory;
	description: string;
}

export type AuthProviderCallbackParams = {
	code: string;
	state: string;
};

export type CheckHealth200 = {
	status: "ok";
	mongoStatus: boolean;
};

export type GetModsParams = {
	/**
	 * @minimum 1
	 */
	page: number;
	/**
	 * @minimum 1
	 */
	size: number;
	category?: GetModsCategory;
	maintainers?: string;
	tags?: string;
	term?: string;
};

export type GetModsCategory = (typeof GetModsCategory)[keyof typeof GetModsCategory];

export const GetModsCategory = {
	CAMPAIGN: "CAMPAIGN",
	DEVICE_PROFILES: "DEVICE_PROFILES",
	MOD: "MOD",
	MISSION: "MISSION",
	SKIN: "SKIN",
	SOUND: "SOUND",
	TERRAIN: "TERRAIN",
	UTILITY: "UTILITY",
	OTHER: "OTHER",
} as const;

export type GetMods200Page = {
	/** @minimum 1 */
	size: number;
	/** @minimum 0 */
	totalElements: number;
	/** @minimum 1 */
	totalPages: number;
	/** @minimum 1 */
	number: number;
};

export type GetMods200 = {
	data: ModSummaryData[];
	page: GetMods200Page;
	filter: ModAvailableFilterData;
};

export type GetModById200 = {
	mod: ModData;
	maintainers: UserData[];
};

export type GetModById404 = {
	message: string;
};

export type GetModReleases200 = {
	data: ModReleaseData[];
};

export type GetLatestModReleaseById404Error =
	(typeof GetLatestModReleaseById404Error)[keyof typeof GetLatestModReleaseById404Error];

export const GetLatestModReleaseById404Error = {
	ModNotFound: "ModNotFound",
	ReleaseNotFound: "ReleaseNotFound",
} as const;

export type GetLatestModReleaseById404 = {
	/**
	 * @minimum 100
	 * @maximum 599
	 */
	code: number;
	message?: string;
	error: GetLatestModReleaseById404Error;
};

export type RegisterModReleaseDownloadByIdBody = {
	daemonInstanceId: string;
};

export type GetServerMetrics200 = {
	totalMods: number;
	totalDownloads: number;
};

export type GetCategories200 = { [key: string]: number };

export type GetUserMods200 = {
	data: ModSummaryData[];
	meta: UserModsMetaData;
};

export type UpdateUserModBodyCategory = (typeof UpdateUserModBodyCategory)[keyof typeof UpdateUserModBodyCategory];

export const UpdateUserModBodyCategory = {
	CAMPAIGN: "CAMPAIGN",
	DEVICE_PROFILES: "DEVICE_PROFILES",
	MOD: "MOD",
	MISSION: "MISSION",
	SKIN: "SKIN",
	SOUND: "SOUND",
	TERRAIN: "TERRAIN",
	UTILITY: "UTILITY",
	OTHER: "OTHER",
} as const;

export type UpdateUserModBodyVisibility =
	(typeof UpdateUserModBodyVisibility)[keyof typeof UpdateUserModBodyVisibility];

export const UpdateUserModBodyVisibility = {
	PUBLIC: "PUBLIC",
	PRIVATE: "PRIVATE",
	UNLISTED: "UNLISTED",
} as const;

export type UpdateUserModBody = {
	category: UpdateUserModBodyCategory;
	content: string;
	dependencies: string[];
	description: string;
	latestReleaseId?: string | null;
	/** @minItems 1 */
	maintainers: string[];
	name: string;
	screenshots: string[];
	tags: string[];
	thumbnail: string;
	visibility: UpdateUserModBodyVisibility;
};

export type GetUserModReleases200 = {
	data: ModReleaseData[];
};

export type CreateUserModReleaseBody = {
	version: string;
};

export type UpdateUserModReleaseBodyVisibility =
	(typeof UpdateUserModReleaseBodyVisibility)[keyof typeof UpdateUserModReleaseBodyVisibility];

export const UpdateUserModReleaseBodyVisibility = {
	PUBLIC: "PUBLIC",
	PRIVATE: "PRIVATE",
	UNLISTED: "UNLISTED",
} as const;

export type UpdateUserModReleaseBody = {
	version: string;
	changelog: string;
	assets: ModReleaseAssetData[];
	symbolicLinks: ModReleaseSymbolicLinkData[];
	missionScripts: ModReleaseMissionScriptData[];
	visibility: UpdateUserModReleaseBodyVisibility;
	downloadsCount?: number;
	createdAt?: string;
	updatedAt?: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Handles the OAuth callback from the selected provider and establishes a user session via a signed cookie.
 * @summary OAuth provider callback
 */
export type authProviderCallbackResponse302 = {
	data: void;
	status: 302;
};
export type authProviderCallbackResponseError = authProviderCallbackResponse302 & {
	headers: Headers;
};

export type authProviderCallbackResponse = authProviderCallbackResponseError;

export const getAuthProviderCallbackUrl = (params: AuthProviderCallbackParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0 ? `/auth/callback?${stringifiedParams}` : `/auth/callback`;
};

export const authProviderCallback = async (
	params: AuthProviderCallbackParams,
	options?: RequestInit,
): Promise<authProviderCallbackResponse> => {
	return fetch<authProviderCallbackResponse>(getAuthProviderCallbackUrl(params), {
		...options,
		method: "GET",
	});
};

export const getAuthProviderCallbackQueryKey = (params?: AuthProviderCallbackParams) => {
	return [`/auth/callback`, ...(params ? [params] : [])] as const;
};

export const getAuthProviderCallbackQueryOptions = <
	TData = Awaited<ReturnType<typeof authProviderCallback>>,
	TError = void,
>(
	params: AuthProviderCallbackParams,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof authProviderCallback>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAuthProviderCallbackQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof authProviderCallback>>> = ({ signal }) =>
		authProviderCallback(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof authProviderCallback>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type AuthProviderCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof authProviderCallback>>>;
export type AuthProviderCallbackQueryError = void;

/**
 * @summary OAuth provider callback
 */

export function useAuthProviderCallback<TData = Awaited<ReturnType<typeof authProviderCallback>>, TError = void>(
	params: AuthProviderCallbackParams,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof authProviderCallback>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getAuthProviderCallbackQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Initiates the OAuth web flow for the selected provider and redirects the user to the provider's authorization page.
 * @summary Start OAuth login
 */
export type authProviderLoginResponse302 = {
	data: void;
	status: 302;
};
export type authProviderLoginResponseError = authProviderLoginResponse302 & {
	headers: Headers;
};

export type authProviderLoginResponse = authProviderLoginResponseError;

export const getAuthProviderLoginUrl = () => {
	return `/auth/login`;
};

export const authProviderLogin = async (options?: RequestInit): Promise<authProviderLoginResponse> => {
	return fetch<authProviderLoginResponse>(getAuthProviderLoginUrl(), {
		...options,
		method: "GET",
	});
};

export const getAuthProviderLoginQueryKey = () => {
	return [`/auth/login`] as const;
};

export const getAuthProviderLoginQueryOptions = <
	TData = Awaited<ReturnType<typeof authProviderLogin>>,
	TError = void,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof authProviderLogin>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAuthProviderLoginQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof authProviderLogin>>> = ({ signal }) =>
		authProviderLogin({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof authProviderLogin>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type AuthProviderLoginQueryResult = NonNullable<Awaited<ReturnType<typeof authProviderLogin>>>;
export type AuthProviderLoginQueryError = void;

/**
 * @summary Start OAuth login
 */

export function useAuthProviderLogin<TData = Awaited<ReturnType<typeof authProviderLogin>>, TError = void>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof authProviderLogin>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getAuthProviderLoginQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Returns the authenticated user's profile derived from the session cookie.
 * @summary Get authenticated user
 */
export type getAuthenticatedUserResponse200 = {
	data: UserData;
	status: 200;
};

export type getAuthenticatedUserResponse401 = {
	data: ErrorData;
	status: 401;
};

export type getAuthenticatedUserResponseSuccess = getAuthenticatedUserResponse200 & {
	headers: Headers;
};
export type getAuthenticatedUserResponseError = getAuthenticatedUserResponse401 & {
	headers: Headers;
};

export type getAuthenticatedUserResponse = getAuthenticatedUserResponseSuccess | getAuthenticatedUserResponseError;

export const getGetAuthenticatedUserUrl = () => {
	return `/auth/user`;
};

export const getAuthenticatedUser = async (options?: RequestInit): Promise<getAuthenticatedUserResponse> => {
	return fetch<getAuthenticatedUserResponse>(getGetAuthenticatedUserUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetAuthenticatedUserQueryKey = () => {
	return [`/auth/user`] as const;
};

export const getGetAuthenticatedUserQueryOptions = <
	TData = Awaited<ReturnType<typeof getAuthenticatedUser>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedUser>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAuthenticatedUserQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthenticatedUser>>> = ({ signal }) =>
		getAuthenticatedUser({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAuthenticatedUser>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAuthenticatedUserQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthenticatedUser>>>;
export type GetAuthenticatedUserQueryError = ErrorData;

/**
 * @summary Get authenticated user
 */

export function useGetAuthenticatedUser<
	TData = Awaited<ReturnType<typeof getAuthenticatedUser>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getAuthenticatedUser>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetAuthenticatedUserQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Clears the authentication cookie and redirects to the homepage.
 * @summary Logout
 */
export type logoutResponse302 = {
	data: void;
	status: 302;
};

export type logoutResponse401 = {
	data: void;
	status: 401;
};
export type logoutResponseError = (logoutResponse302 | logoutResponse401) & {
	headers: Headers;
};

export type logoutResponse = logoutResponseError;

export const getLogoutUrl = () => {
	return `/auth/logout`;
};

export const logout = async (options?: RequestInit): Promise<logoutResponse> => {
	return fetch<logoutResponse>(getLogoutUrl(), {
		...options,
		method: "GET",
	});
};

export const getLogoutQueryKey = () => {
	return [`/auth/logout`] as const;
};

export const getLogoutQueryOptions = <TData = Awaited<ReturnType<typeof logout>>, TError = void>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getLogoutQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof logout>>> = ({ signal }) =>
		logout({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof logout>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type LogoutQueryResult = NonNullable<Awaited<ReturnType<typeof logout>>>;
export type LogoutQueryError = void;

/**
 * @summary Logout
 */

export function useLogout<TData = Awaited<ReturnType<typeof logout>>, TError = void>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof logout>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getLogoutQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Checks the health status of the application.
 * @summary Health Check
 */
export type checkHealthResponse200 = {
	data: CheckHealth200;
	status: 200;
};

export type checkHealthResponse503 = {
	data: ErrorData;
	status: 503;
};

export type checkHealthResponseSuccess = checkHealthResponse200 & {
	headers: Headers;
};
export type checkHealthResponseError = checkHealthResponse503 & {
	headers: Headers;
};

export type checkHealthResponse = checkHealthResponseSuccess | checkHealthResponseError;

export const getCheckHealthUrl = () => {
	return `/api/health`;
};

export const checkHealth = async (options?: RequestInit): Promise<checkHealthResponse> => {
	return fetch<checkHealthResponse>(getCheckHealthUrl(), {
		...options,
		method: "GET",
	});
};

export const getCheckHealthQueryKey = () => {
	return [`/api/health`] as const;
};

export const getCheckHealthQueryOptions = <
	TData = Awaited<ReturnType<typeof checkHealth>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof checkHealth>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getCheckHealthQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof checkHealth>>> = ({ signal }) =>
		checkHealth({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof checkHealth>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type CheckHealthQueryResult = NonNullable<Awaited<ReturnType<typeof checkHealth>>>;
export type CheckHealthQueryError = ErrorData;

/**
 * @summary Health Check
 */

export function useCheckHealth<TData = Awaited<ReturnType<typeof checkHealth>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof checkHealth>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getCheckHealthQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a paginated list of all published mods.
 * @summary Get mods
 */
export type getModsResponse200 = {
	data: GetMods200;
	status: 200;
};

export type getModsResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getModsResponseSuccess = getModsResponse200 & {
	headers: Headers;
};
export type getModsResponseError = getModsResponse500 & {
	headers: Headers;
};

export type getModsResponse = getModsResponseSuccess | getModsResponseError;

export const getGetModsUrl = (params: GetModsParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0 ? `/api/mods?${stringifiedParams}` : `/api/mods`;
};

export const getMods = async (params: GetModsParams, options?: RequestInit): Promise<getModsResponse> => {
	return fetch<getModsResponse>(getGetModsUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetModsQueryKey = (params?: GetModsParams) => {
	return [`/api/mods`, ...(params ? [params] : [])] as const;
};

export const getGetModsQueryOptions = <TData = Awaited<ReturnType<typeof getMods>>, TError = ErrorData>(
	params: GetModsParams,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getMods>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetModsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMods>>> = ({ signal }) =>
		getMods(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getMods>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetModsQueryResult = NonNullable<Awaited<ReturnType<typeof getMods>>>;
export type GetModsQueryError = ErrorData;

/**
 * @summary Get mods
 */

export function useGetMods<TData = Awaited<ReturnType<typeof getMods>>, TError = ErrorData>(
	params: GetModsParams,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getMods>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetModsQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a specific published mod by its ID.
 * @summary Get mod by ID
 */
export type getModByIdResponse200 = {
	data: GetModById200;
	status: 200;
};

export type getModByIdResponse404 = {
	data: GetModById404;
	status: 404;
};

export type getModByIdResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getModByIdResponseSuccess = getModByIdResponse200 & {
	headers: Headers;
};
export type getModByIdResponseError = (getModByIdResponse404 | getModByIdResponse500) & {
	headers: Headers;
};

export type getModByIdResponse = getModByIdResponseSuccess | getModByIdResponseError;

export const getGetModByIdUrl = (id: string) => {
	return `/api/mods/${id}`;
};

export const getModById = async (id: string, options?: RequestInit): Promise<getModByIdResponse> => {
	return fetch<getModByIdResponse>(getGetModByIdUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetModByIdQueryKey = (id: string) => {
	return [`/api/mods/${id}`] as const;
};

export const getGetModByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getModById>>,
	TError = GetModById404 | ErrorData,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getModById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetModByIdQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getModById>>> = ({ signal }) =>
		getModById(id, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getModById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetModByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getModById>>>;
export type GetModByIdQueryError = GetModById404 | ErrorData;

/**
 * @summary Get mod by ID
 */

export function useGetModById<TData = Awaited<ReturnType<typeof getModById>>, TError = GetModById404 | ErrorData>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getModById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetModByIdQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves all public releases for a specific mod.
 * @summary Get mod releases
 */
export type getModReleasesResponse200 = {
	data: GetModReleases200;
	status: 200;
};

export type getModReleasesResponse404 = {
	data: ErrorData;
	status: 404;
};

export type getModReleasesResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getModReleasesResponseSuccess = getModReleasesResponse200 & {
	headers: Headers;
};
export type getModReleasesResponseError = (getModReleasesResponse404 | getModReleasesResponse500) & {
	headers: Headers;
};

export type getModReleasesResponse = getModReleasesResponseSuccess | getModReleasesResponseError;

export const getGetModReleasesUrl = (id: string) => {
	return `/api/mods/${id}/releases`;
};

export const getModReleases = async (id: string, options?: RequestInit): Promise<getModReleasesResponse> => {
	return fetch<getModReleasesResponse>(getGetModReleasesUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetModReleasesQueryKey = (id: string) => {
	return [`/api/mods/${id}/releases`] as const;
};

export const getGetModReleasesQueryOptions = <TData = Awaited<ReturnType<typeof getModReleases>>, TError = ErrorData>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getModReleases>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetModReleasesQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getModReleases>>> = ({ signal }) =>
		getModReleases(id, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getModReleases>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetModReleasesQueryResult = NonNullable<Awaited<ReturnType<typeof getModReleases>>>;
export type GetModReleasesQueryError = ErrorData;

/**
 * @summary Get mod releases
 */

export function useGetModReleases<TData = Awaited<ReturnType<typeof getModReleases>>, TError = ErrorData>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getModReleases>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetModReleasesQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves the latest public release for a mod by its ID.
 * @summary Get latest mod release by ID
 */
export type getLatestModReleaseByIdResponse200 = {
	data: ModReleaseData;
	status: 200;
};

export type getLatestModReleaseByIdResponse404 = {
	data: GetLatestModReleaseById404;
	status: 404;
};

export type getLatestModReleaseByIdResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getLatestModReleaseByIdResponseSuccess = getLatestModReleaseByIdResponse200 & {
	headers: Headers;
};
export type getLatestModReleaseByIdResponseError = (
	| getLatestModReleaseByIdResponse404
	| getLatestModReleaseByIdResponse500
) & {
	headers: Headers;
};

export type getLatestModReleaseByIdResponse =
	| getLatestModReleaseByIdResponseSuccess
	| getLatestModReleaseByIdResponseError;

export const getGetLatestModReleaseByIdUrl = (id: string) => {
	return `/api/mods/${id}/releases/latest`;
};

export const getLatestModReleaseById = async (
	id: string,
	options?: RequestInit,
): Promise<getLatestModReleaseByIdResponse> => {
	return fetch<getLatestModReleaseByIdResponse>(getGetLatestModReleaseByIdUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetLatestModReleaseByIdQueryKey = (id: string) => {
	return [`/api/mods/${id}/releases/latest`] as const;
};

export const getGetLatestModReleaseByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getLatestModReleaseById>>,
	TError = GetLatestModReleaseById404 | ErrorData,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getLatestModReleaseById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetLatestModReleaseByIdQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getLatestModReleaseById>>> = ({ signal }) =>
		getLatestModReleaseById(id, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getLatestModReleaseById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetLatestModReleaseByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getLatestModReleaseById>>>;
export type GetLatestModReleaseByIdQueryError = GetLatestModReleaseById404 | ErrorData;

/**
 * @summary Get latest mod release by ID
 */

export function useGetLatestModReleaseById<
	TData = Awaited<ReturnType<typeof getLatestModReleaseById>>,
	TError = GetLatestModReleaseById404 | ErrorData,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getLatestModReleaseById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetLatestModReleaseByIdQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a specific public release for a mod by its ID.
 * @summary Get mod release by ID
 */
export type getModReleaseByIdResponse200 = {
	data: ModReleaseData;
	status: 200;
};

export type getModReleaseByIdResponse404 = {
	data: ErrorData;
	status: 404;
};

export type getModReleaseByIdResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getModReleaseByIdResponseSuccess = getModReleaseByIdResponse200 & {
	headers: Headers;
};
export type getModReleaseByIdResponseError = (getModReleaseByIdResponse404 | getModReleaseByIdResponse500) & {
	headers: Headers;
};

export type getModReleaseByIdResponse = getModReleaseByIdResponseSuccess | getModReleaseByIdResponseError;

export const getGetModReleaseByIdUrl = (id: string, releaseId: string) => {
	return `/api/mods/${id}/releases/${releaseId}`;
};

export const getModReleaseById = async (
	id: string,
	releaseId: string,
	options?: RequestInit,
): Promise<getModReleaseByIdResponse> => {
	return fetch<getModReleaseByIdResponse>(getGetModReleaseByIdUrl(id, releaseId), {
		...options,
		method: "GET",
	});
};

export const getGetModReleaseByIdQueryKey = (id: string, releaseId: string) => {
	return [`/api/mods/${id}/releases/${releaseId}`] as const;
};

export const getGetModReleaseByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getModReleaseById>>,
	TError = ErrorData,
>(
	id: string,
	releaseId: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getModReleaseById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetModReleaseByIdQueryKey(id, releaseId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getModReleaseById>>> = ({ signal }) =>
		getModReleaseById(id, releaseId, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!(id && releaseId), ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getModReleaseById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetModReleaseByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getModReleaseById>>>;
export type GetModReleaseByIdQueryError = ErrorData;

/**
 * @summary Get mod release by ID
 */

export function useGetModReleaseById<TData = Awaited<ReturnType<typeof getModReleaseById>>, TError = ErrorData>(
	id: string,
	releaseId: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getModReleaseById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetModReleaseByIdQueryOptions(id, releaseId, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Registers a download for a specific public release for a mod by its ID.
 * @summary Register mod release download by ID
 */
export type registerModReleaseDownloadByIdResponse200 = {
	data: OkData;
	status: 200;
};

export type registerModReleaseDownloadByIdResponse404 = {
	data: ErrorData;
	status: 404;
};

export type registerModReleaseDownloadByIdResponse500 = {
	data: ErrorData;
	status: 500;
};

export type registerModReleaseDownloadByIdResponseSuccess = registerModReleaseDownloadByIdResponse200 & {
	headers: Headers;
};
export type registerModReleaseDownloadByIdResponseError = (
	| registerModReleaseDownloadByIdResponse404
	| registerModReleaseDownloadByIdResponse500
) & {
	headers: Headers;
};

export type registerModReleaseDownloadByIdResponse =
	| registerModReleaseDownloadByIdResponseSuccess
	| registerModReleaseDownloadByIdResponseError;

export const getRegisterModReleaseDownloadByIdUrl = (id: string, releaseId: string) => {
	return `/api/mods/${id}/releases/${releaseId}/downloads`;
};

export const registerModReleaseDownloadById = async (
	id: string,
	releaseId: string,
	registerModReleaseDownloadByIdBody: RegisterModReleaseDownloadByIdBody,
	options?: RequestInit,
): Promise<registerModReleaseDownloadByIdResponse> => {
	return fetch<registerModReleaseDownloadByIdResponse>(getRegisterModReleaseDownloadByIdUrl(id, releaseId), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(registerModReleaseDownloadByIdBody),
	});
};

export const getRegisterModReleaseDownloadByIdMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof registerModReleaseDownloadById>>,
		TError,
		{ id: string; releaseId: string; data: RegisterModReleaseDownloadByIdBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof registerModReleaseDownloadById>>,
	TError,
	{ id: string; releaseId: string; data: RegisterModReleaseDownloadByIdBody },
	TContext
> => {
	const mutationKey = ["registerModReleaseDownloadById"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof registerModReleaseDownloadById>>,
		{ id: string; releaseId: string; data: RegisterModReleaseDownloadByIdBody }
	> = (props) => {
		const { id, releaseId, data } = props ?? {};

		return registerModReleaseDownloadById(id, releaseId, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RegisterModReleaseDownloadByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof registerModReleaseDownloadById>>
>;
export type RegisterModReleaseDownloadByIdMutationBody = RegisterModReleaseDownloadByIdBody;
export type RegisterModReleaseDownloadByIdMutationError = ErrorData;

/**
 * @summary Register mod release download by ID
 */
export const useRegisterModReleaseDownloadById = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof registerModReleaseDownloadById>>,
		TError,
		{ id: string; releaseId: string; data: RegisterModReleaseDownloadByIdBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof registerModReleaseDownloadById>>,
	TError,
	{ id: string; releaseId: string; data: RegisterModReleaseDownloadByIdBody },
	TContext
> => {
	return useMutation(getRegisterModReleaseDownloadByIdMutationOptions(options));
};

/**
 * Retrieves the build metrics.
 * @summary Get Server Metrics
 */
export type getServerMetricsResponse200 = {
	data: GetServerMetrics200;
	status: 200;
};

export type getServerMetricsResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getServerMetricsResponseSuccess = getServerMetricsResponse200 & {
	headers: Headers;
};
export type getServerMetricsResponseError = getServerMetricsResponse500 & {
	headers: Headers;
};

export type getServerMetricsResponse = getServerMetricsResponseSuccess | getServerMetricsResponseError;

export const getGetServerMetricsUrl = () => {
	return `/api/server-metrics`;
};

export const getServerMetrics = async (options?: RequestInit): Promise<getServerMetricsResponse> => {
	return fetch<getServerMetricsResponse>(getGetServerMetricsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetServerMetricsQueryKey = () => {
	return [`/api/server-metrics`] as const;
};

export const getGetServerMetricsQueryOptions = <
	TData = Awaited<ReturnType<typeof getServerMetrics>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getServerMetrics>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetServerMetricsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getServerMetrics>>> = ({ signal }) =>
		getServerMetrics({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getServerMetrics>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetServerMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getServerMetrics>>>;
export type GetServerMetricsQueryError = ErrorData;

/**
 * @summary Get Server Metrics
 */

export function useGetServerMetrics<
	TData = Awaited<ReturnType<typeof getServerMetrics>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getServerMetrics>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetServerMetricsQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a set of featured mods.
 * @summary Get Featured mods
 */
export type getFeaturedModsResponse200 = {
	data: ModSummaryData[];
	status: 200;
};

export type getFeaturedModsResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getFeaturedModsResponseSuccess = getFeaturedModsResponse200 & {
	headers: Headers;
};
export type getFeaturedModsResponseError = getFeaturedModsResponse500 & {
	headers: Headers;
};

export type getFeaturedModsResponse = getFeaturedModsResponseSuccess | getFeaturedModsResponseError;

export const getGetFeaturedModsUrl = () => {
	return `/api/featured-mods`;
};

export const getFeaturedMods = async (options?: RequestInit): Promise<getFeaturedModsResponse> => {
	return fetch<getFeaturedModsResponse>(getGetFeaturedModsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetFeaturedModsQueryKey = () => {
	return [`/api/featured-mods`] as const;
};

export const getGetFeaturedModsQueryOptions = <
	TData = Awaited<ReturnType<typeof getFeaturedMods>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getFeaturedMods>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetFeaturedModsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeaturedMods>>> = ({ signal }) =>
		getFeaturedMods({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getFeaturedMods>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetFeaturedModsQueryResult = NonNullable<Awaited<ReturnType<typeof getFeaturedMods>>>;
export type GetFeaturedModsQueryError = ErrorData;

/**
 * @summary Get Featured mods
 */

export function useGetFeaturedMods<TData = Awaited<ReturnType<typeof getFeaturedMods>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getFeaturedMods>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetFeaturedModsQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a set of popular mods.
 * @summary Get Popular mods
 */
export type getPopularModsResponse200 = {
	data: ModSummaryData[];
	status: 200;
};

export type getPopularModsResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getPopularModsResponseSuccess = getPopularModsResponse200 & {
	headers: Headers;
};
export type getPopularModsResponseError = getPopularModsResponse500 & {
	headers: Headers;
};

export type getPopularModsResponse = getPopularModsResponseSuccess | getPopularModsResponseError;

export const getGetPopularModsUrl = () => {
	return `/api/popular-mods`;
};

export const getPopularMods = async (options?: RequestInit): Promise<getPopularModsResponse> => {
	return fetch<getPopularModsResponse>(getGetPopularModsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetPopularModsQueryKey = () => {
	return [`/api/popular-mods`] as const;
};

export const getGetPopularModsQueryOptions = <
	TData = Awaited<ReturnType<typeof getPopularMods>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getPopularMods>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetPopularModsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getPopularMods>>> = ({ signal }) =>
		getPopularMods({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getPopularMods>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetPopularModsQueryResult = NonNullable<Awaited<ReturnType<typeof getPopularMods>>>;
export type GetPopularModsQueryError = ErrorData;

/**
 * @summary Get Popular mods
 */

export function useGetPopularMods<TData = Awaited<ReturnType<typeof getPopularMods>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getPopularMods>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetPopularModsQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a list of all mod categories along with the count of published mods in each category.
 * @summary Get Categories
 */
export type getCategoriesResponse200 = {
	data: GetCategories200;
	status: 200;
};

export type getCategoriesResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getCategoriesResponseSuccess = getCategoriesResponse200 & {
	headers: Headers;
};
export type getCategoriesResponseError = getCategoriesResponse500 & {
	headers: Headers;
};

export type getCategoriesResponse = getCategoriesResponseSuccess | getCategoriesResponseError;

export const getGetCategoriesUrl = () => {
	return `/api/categories`;
};

export const getCategories = async (options?: RequestInit): Promise<getCategoriesResponse> => {
	return fetch<getCategoriesResponse>(getGetCategoriesUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetCategoriesQueryKey = () => {
	return [`/api/categories`] as const;
};

export const getGetCategoriesQueryOptions = <
	TData = Awaited<ReturnType<typeof getCategories>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) =>
		getCategories({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCategories>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>;
export type GetCategoriesQueryError = ErrorData;

/**
 * @summary Get Categories
 */

export function useGetCategories<TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetCategoriesQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a list of all tags.
 * @summary Get Tags
 */
export type getTagsResponse200 = {
	data: string[];
	status: 200;
};

export type getTagsResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getTagsResponseSuccess = getTagsResponse200 & {
	headers: Headers;
};
export type getTagsResponseError = getTagsResponse500 & {
	headers: Headers;
};

export type getTagsResponse = getTagsResponseSuccess | getTagsResponseError;

export const getGetTagsUrl = () => {
	return `/api/tags`;
};

export const getTags = async (options?: RequestInit): Promise<getTagsResponse> => {
	return fetch<getTagsResponse>(getGetTagsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetTagsQueryKey = () => {
	return [`/api/tags`] as const;
};

export const getGetTagsQueryOptions = <TData = Awaited<ReturnType<typeof getTags>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetTagsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTags>>> = ({ signal }) =>
		getTags({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getTags>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetTagsQueryResult = NonNullable<Awaited<ReturnType<typeof getTags>>>;
export type GetTagsQueryError = ErrorData;

/**
 * @summary Get Tags
 */

export function useGetTags<TData = Awaited<ReturnType<typeof getTags>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getTags>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetTagsQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Retrieves a list of all mods owned by the authenticated user.
 * @summary Get user mods
 */
export type getUserModsResponse200 = {
	data: GetUserMods200;
	status: 200;
};

export type getUserModsResponse401 = {
	data: ErrorData;
	status: 401;
};

export type getUserModsResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getUserModsResponseSuccess = getUserModsResponse200 & {
	headers: Headers;
};
export type getUserModsResponseError = (getUserModsResponse401 | getUserModsResponse500) & {
	headers: Headers;
};

export type getUserModsResponse = getUserModsResponseSuccess | getUserModsResponseError;

export const getGetUserModsUrl = () => {
	return `/api/user-mods`;
};

export const getUserMods = async (options?: RequestInit): Promise<getUserModsResponse> => {
	return fetch<getUserModsResponse>(getGetUserModsUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetUserModsQueryKey = () => {
	return [`/api/user-mods`] as const;
};

export const getGetUserModsQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserMods>>,
	TError = ErrorData,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getUserMods>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUserModsQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserMods>>> = ({ signal }) =>
		getUserMods({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserMods>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetUserModsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserMods>>>;
export type GetUserModsQueryError = ErrorData;

/**
 * @summary Get user mods
 */

export function useGetUserMods<TData = Awaited<ReturnType<typeof getUserMods>>, TError = ErrorData>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getUserMods>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetUserModsQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Creates a new mod owned by the authenticated user.
 * @summary Create user mod
 */
export type createUserModResponse201 = {
	data: ModData;
	status: 201;
};

export type createUserModResponse401 = {
	data: ErrorData;
	status: 401;
};

export type createUserModResponse500 = {
	data: ErrorData;
	status: 500;
};

export type createUserModResponseSuccess = createUserModResponse201 & {
	headers: Headers;
};
export type createUserModResponseError = (createUserModResponse401 | createUserModResponse500) & {
	headers: Headers;
};

export type createUserModResponse = createUserModResponseSuccess | createUserModResponseError;

export const getCreateUserModUrl = () => {
	return `/api/user-mods`;
};

export const createUserMod = async (
	modCreateData: ModCreateData,
	options?: RequestInit,
): Promise<createUserModResponse> => {
	return fetch<createUserModResponse>(getCreateUserModUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(modCreateData),
	});
};

export const getCreateUserModMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof createUserMod>>, TError, { data: ModCreateData }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof createUserMod>>, TError, { data: ModCreateData }, TContext> => {
	const mutationKey = ["createUserMod"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUserMod>>, { data: ModCreateData }> = (props) => {
		const { data } = props ?? {};

		return createUserMod(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateUserModMutationResult = NonNullable<Awaited<ReturnType<typeof createUserMod>>>;
export type CreateUserModMutationBody = ModCreateData;
export type CreateUserModMutationError = ErrorData;

/**
 * @summary Create user mod
 */
export const useCreateUserMod = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof createUserMod>>, TError, { data: ModCreateData }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<Awaited<ReturnType<typeof createUserMod>>, TError, { data: ModCreateData }, TContext> => {
	return useMutation(getCreateUserModMutationOptions(options));
};

/**
 * Retrieves a specific mod owned by the authenticated user by its ID.
 * @summary Get user mod by ID
 */
export type getUserModByIdResponse200 = {
	data: ModData;
	status: 200;
};

export type getUserModByIdResponse401 = {
	data: ErrorData;
	status: 401;
};

export type getUserModByIdResponse404 = {
	data: ErrorData;
	status: 404;
};

export type getUserModByIdResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getUserModByIdResponseSuccess = getUserModByIdResponse200 & {
	headers: Headers;
};
export type getUserModByIdResponseError = (
	| getUserModByIdResponse401
	| getUserModByIdResponse404
	| getUserModByIdResponse500
) & {
	headers: Headers;
};

export type getUserModByIdResponse = getUserModByIdResponseSuccess | getUserModByIdResponseError;

export const getGetUserModByIdUrl = (id: string) => {
	return `/api/user-mods/${id}`;
};

export const getUserModById = async (id: string, options?: RequestInit): Promise<getUserModByIdResponse> => {
	return fetch<getUserModByIdResponse>(getGetUserModByIdUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetUserModByIdQueryKey = (id: string) => {
	return [`/api/user-mods/${id}`] as const;
};

export const getGetUserModByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserModById>>, TError = ErrorData>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getUserModById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUserModByIdQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserModById>>> = ({ signal }) =>
		getUserModById(id, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserModById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetUserModByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserModById>>>;
export type GetUserModByIdQueryError = ErrorData;

/**
 * @summary Get user mod by ID
 */

export function useGetUserModById<TData = Awaited<ReturnType<typeof getUserModById>>, TError = ErrorData>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getUserModById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetUserModByIdQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Updates an existing mod owned by the authenticated user.
 * @summary Update user mod
 */
export type updateUserModResponse200 = {
	data: OkData;
	status: 200;
};

export type updateUserModResponse401 = {
	data: ErrorData;
	status: 401;
};

export type updateUserModResponse404 = {
	data: ErrorData;
	status: 404;
};

export type updateUserModResponse500 = {
	data: ErrorData;
	status: 500;
};

export type updateUserModResponseSuccess = updateUserModResponse200 & {
	headers: Headers;
};
export type updateUserModResponseError = (
	| updateUserModResponse401
	| updateUserModResponse404
	| updateUserModResponse500
) & {
	headers: Headers;
};

export type updateUserModResponse = updateUserModResponseSuccess | updateUserModResponseError;

export const getUpdateUserModUrl = (id: string) => {
	return `/api/user-mods/${id}`;
};

export const updateUserMod = async (
	id: string,
	updateUserModBody: UpdateUserModBody,
	options?: RequestInit,
): Promise<updateUserModResponse> => {
	return fetch<updateUserModResponse>(getUpdateUserModUrl(id), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateUserModBody),
	});
};

export const getUpdateUserModMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUserMod>>,
		TError,
		{ id: string; data: UpdateUserModBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateUserMod>>,
	TError,
	{ id: string; data: UpdateUserModBody },
	TContext
> => {
	const mutationKey = ["updateUserMod"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateUserMod>>,
		{ id: string; data: UpdateUserModBody }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateUserMod(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateUserModMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserMod>>>;
export type UpdateUserModMutationBody = UpdateUserModBody;
export type UpdateUserModMutationError = ErrorData;

/**
 * @summary Update user mod
 */
export const useUpdateUserMod = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUserMod>>,
		TError,
		{ id: string; data: UpdateUserModBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateUserMod>>,
	TError,
	{ id: string; data: UpdateUserModBody },
	TContext
> => {
	return useMutation(getUpdateUserModMutationOptions(options));
};

/**
 * Deletes an existing mod owned by the authenticated user.
 * @summary Delete user mod
 */
export type deleteUserModResponse200 = {
	data: OkData;
	status: 200;
};

export type deleteUserModResponse401 = {
	data: ErrorData;
	status: 401;
};

export type deleteUserModResponse404 = {
	data: ErrorData;
	status: 404;
};

export type deleteUserModResponse500 = {
	data: ErrorData;
	status: 500;
};

export type deleteUserModResponseSuccess = deleteUserModResponse200 & {
	headers: Headers;
};
export type deleteUserModResponseError = (
	| deleteUserModResponse401
	| deleteUserModResponse404
	| deleteUserModResponse500
) & {
	headers: Headers;
};

export type deleteUserModResponse = deleteUserModResponseSuccess | deleteUserModResponseError;

export const getDeleteUserModUrl = (id: string) => {
	return `/api/user-mods/${id}`;
};

export const deleteUserMod = async (id: string, options?: RequestInit): Promise<deleteUserModResponse> => {
	return fetch<deleteUserModResponse>(getDeleteUserModUrl(id), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteUserModMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserMod>>, TError, { id: string }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteUserMod>>, TError, { id: string }, TContext> => {
	const mutationKey = ["deleteUserMod"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserMod>>, { id: string }> = (props) => {
		const { id } = props ?? {};

		return deleteUserMod(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteUserModMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserMod>>>;

export type DeleteUserModMutationError = ErrorData;

/**
 * @summary Delete user mod
 */
export const useDeleteUserMod = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteUserMod>>, TError, { id: string }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<Awaited<ReturnType<typeof deleteUserMod>>, TError, { id: string }, TContext> => {
	return useMutation(getDeleteUserModMutationOptions(options));
};

/**
 * Retrieves all releases for a specific mod owned by the authenticated user.
 * @summary Get user mod releases
 */
export type getUserModReleasesResponse200 = {
	data: GetUserModReleases200;
	status: 200;
};

export type getUserModReleasesResponse401 = {
	data: ErrorData;
	status: 401;
};

export type getUserModReleasesResponse404 = {
	data: ErrorData;
	status: 404;
};

export type getUserModReleasesResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getUserModReleasesResponseSuccess = getUserModReleasesResponse200 & {
	headers: Headers;
};
export type getUserModReleasesResponseError = (
	| getUserModReleasesResponse401
	| getUserModReleasesResponse404
	| getUserModReleasesResponse500
) & {
	headers: Headers;
};

export type getUserModReleasesResponse = getUserModReleasesResponseSuccess | getUserModReleasesResponseError;

export const getGetUserModReleasesUrl = (id: string) => {
	return `/api/user-mods/${id}/releases`;
};

export const getUserModReleases = async (id: string, options?: RequestInit): Promise<getUserModReleasesResponse> => {
	return fetch<getUserModReleasesResponse>(getGetUserModReleasesUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetUserModReleasesQueryKey = (id: string) => {
	return [`/api/user-mods/${id}/releases`] as const;
};

export const getGetUserModReleasesQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserModReleases>>,
	TError = ErrorData,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getUserModReleases>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUserModReleasesQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserModReleases>>> = ({ signal }) =>
		getUserModReleases(id, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserModReleases>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetUserModReleasesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserModReleases>>>;
export type GetUserModReleasesQueryError = ErrorData;

/**
 * @summary Get user mod releases
 */

export function useGetUserModReleases<TData = Awaited<ReturnType<typeof getUserModReleases>>, TError = ErrorData>(
	id: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getUserModReleases>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetUserModReleasesQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Creates a new release for a mod owned by the authenticated user.
 * @summary Create user mod release
 */
export type createUserModReleaseResponse201 = {
	data: ModReleaseData;
	status: 201;
};

export type createUserModReleaseResponse401 = {
	data: ErrorData;
	status: 401;
};

export type createUserModReleaseResponse404 = {
	data: ErrorData;
	status: 404;
};

export type createUserModReleaseResponse500 = {
	data: ErrorData;
	status: 500;
};

export type createUserModReleaseResponseSuccess = createUserModReleaseResponse201 & {
	headers: Headers;
};
export type createUserModReleaseResponseError = (
	| createUserModReleaseResponse401
	| createUserModReleaseResponse404
	| createUserModReleaseResponse500
) & {
	headers: Headers;
};

export type createUserModReleaseResponse = createUserModReleaseResponseSuccess | createUserModReleaseResponseError;

export const getCreateUserModReleaseUrl = (id: string) => {
	return `/api/user-mods/${id}/releases`;
};

export const createUserModRelease = async (
	id: string,
	createUserModReleaseBody: CreateUserModReleaseBody,
	options?: RequestInit,
): Promise<createUserModReleaseResponse> => {
	return fetch<createUserModReleaseResponse>(getCreateUserModReleaseUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createUserModReleaseBody),
	});
};

export const getCreateUserModReleaseMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createUserModRelease>>,
		TError,
		{ id: string; data: CreateUserModReleaseBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createUserModRelease>>,
	TError,
	{ id: string; data: CreateUserModReleaseBody },
	TContext
> => {
	const mutationKey = ["createUserModRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createUserModRelease>>,
		{ id: string; data: CreateUserModReleaseBody }
	> = (props) => {
		const { id, data } = props ?? {};

		return createUserModRelease(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateUserModReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof createUserModRelease>>>;
export type CreateUserModReleaseMutationBody = CreateUserModReleaseBody;
export type CreateUserModReleaseMutationError = ErrorData;

/**
 * @summary Create user mod release
 */
export const useCreateUserModRelease = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createUserModRelease>>,
		TError,
		{ id: string; data: CreateUserModReleaseBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof createUserModRelease>>,
	TError,
	{ id: string; data: CreateUserModReleaseBody },
	TContext
> => {
	return useMutation(getCreateUserModReleaseMutationOptions(options));
};

/**
 * Retrieves a specific release for a user-owned mod by its ID.
 * @summary Get user mod release by ID
 */
export type getUserModReleaseByIdResponse200 = {
	data: ModReleaseData;
	status: 200;
};

export type getUserModReleaseByIdResponse401 = {
	data: ErrorData;
	status: 401;
};

export type getUserModReleaseByIdResponse404 = {
	data: ErrorData;
	status: 404;
};

export type getUserModReleaseByIdResponse500 = {
	data: ErrorData;
	status: 500;
};

export type getUserModReleaseByIdResponseSuccess = getUserModReleaseByIdResponse200 & {
	headers: Headers;
};
export type getUserModReleaseByIdResponseError = (
	| getUserModReleaseByIdResponse401
	| getUserModReleaseByIdResponse404
	| getUserModReleaseByIdResponse500
) & {
	headers: Headers;
};

export type getUserModReleaseByIdResponse = getUserModReleaseByIdResponseSuccess | getUserModReleaseByIdResponseError;

export const getGetUserModReleaseByIdUrl = (id: string, releaseId: string) => {
	return `/api/user-mods/${id}/releases/${releaseId}`;
};

export const getUserModReleaseById = async (
	id: string,
	releaseId: string,
	options?: RequestInit,
): Promise<getUserModReleaseByIdResponse> => {
	return fetch<getUserModReleaseByIdResponse>(getGetUserModReleaseByIdUrl(id, releaseId), {
		...options,
		method: "GET",
	});
};

export const getGetUserModReleaseByIdQueryKey = (id: string, releaseId: string) => {
	return [`/api/user-mods/${id}/releases/${releaseId}`] as const;
};

export const getGetUserModReleaseByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserModReleaseById>>,
	TError = ErrorData,
>(
	id: string,
	releaseId: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getUserModReleaseById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUserModReleaseByIdQueryKey(id, releaseId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserModReleaseById>>> = ({ signal }) =>
		getUserModReleaseById(id, releaseId, { signal, ...requestOptions });

	return { queryKey, queryFn, enabled: !!(id && releaseId), ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserModReleaseById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetUserModReleaseByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserModReleaseById>>>;
export type GetUserModReleaseByIdQueryError = ErrorData;

/**
 * @summary Get user mod release by ID
 */

export function useGetUserModReleaseById<TData = Awaited<ReturnType<typeof getUserModReleaseById>>, TError = ErrorData>(
	id: string,
	releaseId: string,
	options?: {
		query?: UseQueryOptions<Awaited<ReturnType<typeof getUserModReleaseById>>, TError, TData>;
		request?: SecondParameter<typeof fetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetUserModReleaseByIdQueryOptions(id, releaseId, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Updates fields of an existing release for a mod owned by the authenticated user.
 * @summary Update user mod release
 */
export type updateUserModReleaseResponse200 = {
	data: OkData;
	status: 200;
};

export type updateUserModReleaseResponse401 = {
	data: ErrorData;
	status: 401;
};

export type updateUserModReleaseResponse404 = {
	data: ErrorData;
	status: 404;
};

export type updateUserModReleaseResponse500 = {
	data: ErrorData;
	status: 500;
};

export type updateUserModReleaseResponseSuccess = updateUserModReleaseResponse200 & {
	headers: Headers;
};
export type updateUserModReleaseResponseError = (
	| updateUserModReleaseResponse401
	| updateUserModReleaseResponse404
	| updateUserModReleaseResponse500
) & {
	headers: Headers;
};

export type updateUserModReleaseResponse = updateUserModReleaseResponseSuccess | updateUserModReleaseResponseError;

export const getUpdateUserModReleaseUrl = (id: string, releaseId: string) => {
	return `/api/user-mods/${id}/releases/${releaseId}`;
};

export const updateUserModRelease = async (
	id: string,
	releaseId: string,
	updateUserModReleaseBody: UpdateUserModReleaseBody,
	options?: RequestInit,
): Promise<updateUserModReleaseResponse> => {
	return fetch<updateUserModReleaseResponse>(getUpdateUserModReleaseUrl(id, releaseId), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateUserModReleaseBody),
	});
};

export const getUpdateUserModReleaseMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUserModRelease>>,
		TError,
		{ id: string; releaseId: string; data: UpdateUserModReleaseBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateUserModRelease>>,
	TError,
	{ id: string; releaseId: string; data: UpdateUserModReleaseBody },
	TContext
> => {
	const mutationKey = ["updateUserModRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateUserModRelease>>,
		{ id: string; releaseId: string; data: UpdateUserModReleaseBody }
	> = (props) => {
		const { id, releaseId, data } = props ?? {};

		return updateUserModRelease(id, releaseId, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateUserModReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserModRelease>>>;
export type UpdateUserModReleaseMutationBody = UpdateUserModReleaseBody;
export type UpdateUserModReleaseMutationError = ErrorData;

/**
 * @summary Update user mod release
 */
export const useUpdateUserModRelease = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUserModRelease>>,
		TError,
		{ id: string; releaseId: string; data: UpdateUserModReleaseBody },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateUserModRelease>>,
	TError,
	{ id: string; releaseId: string; data: UpdateUserModReleaseBody },
	TContext
> => {
	return useMutation(getUpdateUserModReleaseMutationOptions(options));
};

/**
 * Deletes an existing release for a mod owned by the authenticated user.
 * @summary Delete user mod release
 */
export type deleteUserModReleaseResponse200 = {
	data: OkData;
	status: 200;
};

export type deleteUserModReleaseResponse401 = {
	data: ErrorData;
	status: 401;
};

export type deleteUserModReleaseResponse404 = {
	data: ErrorData;
	status: 404;
};

export type deleteUserModReleaseResponse500 = {
	data: ErrorData;
	status: 500;
};

export type deleteUserModReleaseResponseSuccess = deleteUserModReleaseResponse200 & {
	headers: Headers;
};
export type deleteUserModReleaseResponseError = (
	| deleteUserModReleaseResponse401
	| deleteUserModReleaseResponse404
	| deleteUserModReleaseResponse500
) & {
	headers: Headers;
};

export type deleteUserModReleaseResponse = deleteUserModReleaseResponseSuccess | deleteUserModReleaseResponseError;

export const getDeleteUserModReleaseUrl = (id: string, releaseId: string) => {
	return `/api/user-mods/${id}/releases/${releaseId}`;
};

export const deleteUserModRelease = async (
	id: string,
	releaseId: string,
	options?: RequestInit,
): Promise<deleteUserModReleaseResponse> => {
	return fetch<deleteUserModReleaseResponse>(getDeleteUserModReleaseUrl(id, releaseId), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteUserModReleaseMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteUserModRelease>>,
		TError,
		{ id: string; releaseId: string },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteUserModRelease>>,
	TError,
	{ id: string; releaseId: string },
	TContext
> => {
	const mutationKey = ["deleteUserModRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteUserModRelease>>,
		{ id: string; releaseId: string }
	> = (props) => {
		const { id, releaseId } = props ?? {};

		return deleteUserModRelease(id, releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteUserModReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserModRelease>>>;

export type DeleteUserModReleaseMutationError = ErrorData;

/**
 * @summary Delete user mod release
 */
export const useDeleteUserModRelease = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteUserModRelease>>,
		TError,
		{ id: string; releaseId: string },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteUserModRelease>>,
	TError,
	{ id: string; releaseId: string },
	TContext
> => {
	return useMutation(getDeleteUserModReleaseMutationOptions(options));
};
