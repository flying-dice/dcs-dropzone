/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * DCS Dropzone Daemon API
 * API documentation for the DCS Dropzone Daemon.
 * OpenAPI spec version: 1.0.0
 */

import type {
	MutationFunction,
	QueryFunction,
	QueryKey,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";
import { useMutation, useQuery } from "@tanstack/react-query";

import { fetch } from "./client";
export type ModReleaseAssetStatusDataStatus =
	(typeof ModReleaseAssetStatusDataStatus)[keyof typeof ModReleaseAssetStatusDataStatus];

export const ModReleaseAssetStatusDataStatus = {
	PENDING: "PENDING",
	IN_PROGRESS: "IN_PROGRESS",
	COMPLETED: "COMPLETED",
	ERROR: "ERROR",
} as const;

/**
 * Status data representation of a mod release asset, including download and extraction progress.
 */
export interface ModReleaseAssetStatusData {
	downloadPercentProgress?: number;
	extractPercentProgress?: number;
	overallPercentProgress?: number;
	status: ModReleaseAssetStatusDataStatus;
}

export type ModReleaseAssetDataUrlsItem = {
	id: string;
	url: string;
};

/**
 * Data representation of a mod release asset.
 */
export interface ModReleaseAssetData {
	id: string;
	/** @minLength 1 */
	name: string;
	urls: ModReleaseAssetDataUrlsItem[];
	isArchive: boolean;
	statusData?: ModReleaseAssetStatusData;
}

export type ModReleaseSymbolicLinkDataDestRoot =
	(typeof ModReleaseSymbolicLinkDataDestRoot)[keyof typeof ModReleaseSymbolicLinkDataDestRoot];

export const ModReleaseSymbolicLinkDataDestRoot = {
	DCS_WORKING_DIR: "DCS_WORKING_DIR",
	DCS_INSTALL_DIR: "DCS_INSTALL_DIR",
} as const;

/**
 * Data representation of a symbolic link configuration.
 */
export interface ModReleaseSymbolicLinkData {
	id: string;
	/** @minLength 1 */
	name: string;
	/** @minLength 1 */
	src: string;
	/** @minLength 1 */
	dest: string;
	destRoot: ModReleaseSymbolicLinkDataDestRoot;
}

export type ModReleaseMissionScriptDataRoot =
	(typeof ModReleaseMissionScriptDataRoot)[keyof typeof ModReleaseMissionScriptDataRoot];

export const ModReleaseMissionScriptDataRoot = {
	DCS_WORKING_DIR: "DCS_WORKING_DIR",
	DCS_INSTALL_DIR: "DCS_INSTALL_DIR",
} as const;

export type ModReleaseMissionScriptDataRunOn =
	(typeof ModReleaseMissionScriptDataRunOn)[keyof typeof ModReleaseMissionScriptDataRunOn];

export const ModReleaseMissionScriptDataRunOn = {
	MISSION_START_BEFORE_SANITIZE: "MISSION_START_BEFORE_SANITIZE",
	MISSION_START_AFTER_SANITIZE: "MISSION_START_AFTER_SANITIZE",
} as const;

/**
 * Data representation of a mission script configuration.
 */
export interface ModReleaseMissionScriptData {
	id: string;
	/** @minLength 1 */
	name: string;
	/** @minLength 1 */
	purpose: string;
	/** @minLength 1 */
	path: string;
	root: ModReleaseMissionScriptDataRoot;
	runOn: ModReleaseMissionScriptDataRunOn;
}

export type ModAndReleaseDataStatus = (typeof ModAndReleaseDataStatus)[keyof typeof ModAndReleaseDataStatus];

export const ModAndReleaseDataStatus = {
	PENDING: "PENDING",
	IN_PROGRESS: "IN_PROGRESS",
	DISABLED: "DISABLED",
	ENABLED: "ENABLED",
	ERROR: "ERROR",
} as const;

/**
 * Data representation of a mod along with its release for downloading and enabling.
 */
export interface ModAndReleaseData {
	releaseId: string;
	modId: string;
	modName: string;
	dependencies: string[];
	version: string;
	versionHash: string;
	assets: ModReleaseAssetData[];
	symbolicLinks: ModReleaseSymbolicLinkData[];
	missionScripts: ModReleaseMissionScriptData[];
	status?: ModAndReleaseDataStatus;
	overallPercentProgress?: number;
}

export interface OkData {
	ok?: boolean;
}

export interface ErrorData {
	/**
	 * @minimum 100
	 * @maximum 599
	 */
	code: number;
	message?: string;
	error: string;
}

export type GetDaemonHealth200 = {
	status: "UP";
	daemonInstanceId: string;
};

export type GetDaemonHealth503 = {
	status: "DOWN";
	daemonInstanceId: string;
	error: string;
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export type addReleaseToDaemonResponse200 = {
	data: void;
	status: 200;
};

export type addReleaseToDaemonResponseSuccess = addReleaseToDaemonResponse200 & {
	headers: Headers;
};

export type addReleaseToDaemonResponse = addReleaseToDaemonResponseSuccess;

export const getAddReleaseToDaemonUrl = () => {
	return `/api/downloads`;
};

export const addReleaseToDaemon = async (
	modAndReleaseData: ModAndReleaseData,
	options?: RequestInit,
): Promise<addReleaseToDaemonResponse> => {
	return fetch<addReleaseToDaemonResponse>(getAddReleaseToDaemonUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(modAndReleaseData),
	});
};

export const getAddReleaseToDaemonMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof addReleaseToDaemon>>,
		TError,
		{ data: ModAndReleaseData },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof addReleaseToDaemon>>,
	TError,
	{ data: ModAndReleaseData },
	TContext
> => {
	const mutationKey = ["addReleaseToDaemon"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof addReleaseToDaemon>>, { data: ModAndReleaseData }> = (
		props,
	) => {
		const { data } = props ?? {};

		return addReleaseToDaemon(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AddReleaseToDaemonMutationResult = NonNullable<Awaited<ReturnType<typeof addReleaseToDaemon>>>;
export type AddReleaseToDaemonMutationBody = ModAndReleaseData;
export type AddReleaseToDaemonMutationError = unknown;

export const useAddReleaseToDaemon = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof addReleaseToDaemon>>,
		TError,
		{ data: ModAndReleaseData },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof addReleaseToDaemon>>,
	TError,
	{ data: ModAndReleaseData },
	TContext
> => {
	return useMutation(getAddReleaseToDaemonMutationOptions(options));
};

export type getAllDaemonReleasesResponse200 = {
	data: ModAndReleaseData[];
	status: 200;
};

export type getAllDaemonReleasesResponseSuccess = getAllDaemonReleasesResponse200 & {
	headers: Headers;
};

export type getAllDaemonReleasesResponse = getAllDaemonReleasesResponseSuccess;

export const getGetAllDaemonReleasesUrl = () => {
	return `/api/downloads`;
};

export const getAllDaemonReleases = async (options?: RequestInit): Promise<getAllDaemonReleasesResponse> => {
	return fetch<getAllDaemonReleasesResponse>(getGetAllDaemonReleasesUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetAllDaemonReleasesQueryKey = () => {
	return [`/api/downloads`] as const;
};

export const getGetAllDaemonReleasesQueryOptions = <
	TData = Awaited<ReturnType<typeof getAllDaemonReleases>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAllDaemonReleasesQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllDaemonReleases>>> = ({ signal }) =>
		getAllDaemonReleases({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAllDaemonReleases>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetAllDaemonReleasesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllDaemonReleases>>>;
export type GetAllDaemonReleasesQueryError = unknown;

export function useGetAllDaemonReleases<
	TData = Awaited<ReturnType<typeof getAllDaemonReleases>>,
	TError = unknown,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getAllDaemonReleases>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetAllDaemonReleasesQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

export type removeReleaseFromDaemonResponse200 = {
	data: void;
	status: 200;
};

export type removeReleaseFromDaemonResponseSuccess = removeReleaseFromDaemonResponse200 & {
	headers: Headers;
};

export type removeReleaseFromDaemonResponse = removeReleaseFromDaemonResponseSuccess;

export const getRemoveReleaseFromDaemonUrl = (releaseId: string) => {
	return `/api/downloads/${releaseId}`;
};

export const removeReleaseFromDaemon = async (
	releaseId: string,
	options?: RequestInit,
): Promise<removeReleaseFromDaemonResponse> => {
	return fetch<removeReleaseFromDaemonResponse>(getRemoveReleaseFromDaemonUrl(releaseId), {
		...options,
		method: "DELETE",
	});
};

export const getRemoveReleaseFromDaemonMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof removeReleaseFromDaemon>>,
		TError,
		{ releaseId: string },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof removeReleaseFromDaemon>>,
	TError,
	{ releaseId: string },
	TContext
> => {
	const mutationKey = ["removeReleaseFromDaemon"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeReleaseFromDaemon>>, { releaseId: string }> = (
		props,
	) => {
		const { releaseId } = props ?? {};

		return removeReleaseFromDaemon(releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RemoveReleaseFromDaemonMutationResult = NonNullable<Awaited<ReturnType<typeof removeReleaseFromDaemon>>>;

export type RemoveReleaseFromDaemonMutationError = unknown;

export const useRemoveReleaseFromDaemon = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof removeReleaseFromDaemon>>,
		TError,
		{ releaseId: string },
		TContext
	>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<Awaited<ReturnType<typeof removeReleaseFromDaemon>>, TError, { releaseId: string }, TContext> => {
	return useMutation(getRemoveReleaseFromDaemonMutationOptions(options));
};

/**
 * Checks the daemon service health by performing a lightweight database operation.
 * @summary Daemon health check
 */
export type getDaemonHealthResponse200 = {
	data: GetDaemonHealth200;
	status: 200;
};

export type getDaemonHealthResponse503 = {
	data: GetDaemonHealth503;
	status: 503;
};

export type getDaemonHealthResponseSuccess = getDaemonHealthResponse200 & {
	headers: Headers;
};
export type getDaemonHealthResponseError = getDaemonHealthResponse503 & {
	headers: Headers;
};

export type getDaemonHealthResponse = getDaemonHealthResponseSuccess | getDaemonHealthResponseError;

export const getGetDaemonHealthUrl = () => {
	return `/api/health`;
};

export const getDaemonHealth = async (options?: RequestInit): Promise<getDaemonHealthResponse> => {
	return fetch<getDaemonHealthResponse>(getGetDaemonHealthUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetDaemonHealthQueryKey = () => {
	return [`/api/health`] as const;
};

export const getGetDaemonHealthQueryOptions = <
	TData = Awaited<ReturnType<typeof getDaemonHealth>>,
	TError = GetDaemonHealth503,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetDaemonHealthQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getDaemonHealth>>> = ({ signal }) =>
		getDaemonHealth({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getDaemonHealth>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetDaemonHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getDaemonHealth>>>;
export type GetDaemonHealthQueryError = GetDaemonHealth503;

/**
 * @summary Daemon health check
 */

export function useGetDaemonHealth<
	TData = Awaited<ReturnType<typeof getDaemonHealth>>,
	TError = GetDaemonHealth503,
>(options?: {
	query?: UseQueryOptions<Awaited<ReturnType<typeof getDaemonHealth>>, TError, TData>;
	request?: SecondParameter<typeof fetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetDaemonHealthQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Enable a release by creating its symbolic links
 */
export type enableReleaseResponse200 = {
	data: OkData;
	status: 200;
};

export type enableReleaseResponse500 = {
	data: ErrorData;
	status: 500;
};

export type enableReleaseResponseSuccess = enableReleaseResponse200 & {
	headers: Headers;
};
export type enableReleaseResponseError = enableReleaseResponse500 & {
	headers: Headers;
};

export type enableReleaseResponse = enableReleaseResponseSuccess | enableReleaseResponseError;

export const getEnableReleaseUrl = (releaseId: string) => {
	return `/api/toggle/${releaseId}/enable`;
};

export const enableRelease = async (releaseId: string, options?: RequestInit): Promise<enableReleaseResponse> => {
	return fetch<enableReleaseResponse>(getEnableReleaseUrl(releaseId), {
		...options,
		method: "POST",
	});
};

export const getEnableReleaseMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext> => {
	const mutationKey = ["enableRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableRelease>>, { releaseId: string }> = (props) => {
		const { releaseId } = props ?? {};

		return enableRelease(releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type EnableReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof enableRelease>>>;

export type EnableReleaseMutationError = ErrorData;

/**
 * @summary Enable a release by creating its symbolic links
 */
export const useEnableRelease = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<Awaited<ReturnType<typeof enableRelease>>, TError, { releaseId: string }, TContext> => {
	return useMutation(getEnableReleaseMutationOptions(options));
};

/**
 * @summary Disable a release by removing its symbolic links
 */
export type disableReleaseResponse200 = {
	data: OkData;
	status: 200;
};

export type disableReleaseResponse500 = {
	data: ErrorData;
	status: 500;
};

export type disableReleaseResponseSuccess = disableReleaseResponse200 & {
	headers: Headers;
};
export type disableReleaseResponseError = disableReleaseResponse500 & {
	headers: Headers;
};

export type disableReleaseResponse = disableReleaseResponseSuccess | disableReleaseResponseError;

export const getDisableReleaseUrl = (releaseId: string) => {
	return `/api/toggle/${releaseId}/disable`;
};

export const disableRelease = async (releaseId: string, options?: RequestInit): Promise<disableReleaseResponse> => {
	return fetch<disableReleaseResponse>(getDisableReleaseUrl(releaseId), {
		...options,
		method: "POST",
	});
};

export const getDisableReleaseMutationOptions = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationOptions<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext> => {
	const mutationKey = ["disableRelease"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableRelease>>, { releaseId: string }> = (props) => {
		const { releaseId } = props ?? {};

		return disableRelease(releaseId, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DisableReleaseMutationResult = NonNullable<Awaited<ReturnType<typeof disableRelease>>>;

export type DisableReleaseMutationError = ErrorData;

/**
 * @summary Disable a release by removing its symbolic links
 */
export const useDisableRelease = <TError = ErrorData, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext>;
	request?: SecondParameter<typeof fetch>;
}): UseMutationResult<Awaited<ReturnType<typeof disableRelease>>, TError, { releaseId: string }, TContext> => {
	return useMutation(getDisableReleaseMutationOptions(options));
};
